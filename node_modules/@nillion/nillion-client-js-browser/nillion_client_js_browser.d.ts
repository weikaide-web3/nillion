/* tslint:disable */
/* eslint-disable */
/**
* Cluster descriptor
*
* The cluster descriptor contains relevant cluster configuration information.
* This is the structure returned by the `cluster_information` operation in the client.
*
* @hideconstructor
*/
export class ClusterDescriptor {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* Cluster identifier
* Returns the cluster identifier as a string.
* @return {string} The cluster identifier
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const id = descriptor.id;
*/
  readonly id: string;
/**
* The security parameter kappa for this cluster.
* @return {number} The security parameter kappa
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const kappa = descriptor.kappa;
*/
  readonly kappa: number;
/**
* Cluster parties
* Returns the parties in the cluster.
* @return {Object} The parties in the cluster
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const parties = descriptor.parties;
*/
  readonly parties: any;
/**
* The preprocessing configuration.
* @return {PreprocessingConfig} The preprocessing configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
*/
  readonly preprocessing: PreprocessingConfig;
/**
* The prime number to be used in this cluster.
* @return {string} The prime number as a string
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const prime = descriptor.prime;
*/
  readonly prime: string;
}
/**
* @private
*/
export class LoaderHelper {
  free(): void;
/**
* @returns {string}
*/
  mainJS(): string;
}
/**
* The Nillion Client
*
* This is the main interface with the Nillion network.
* The Nillion Client provides APIs that you can use for:
* - secure computing in Nillion,
* - storing programs,
* - managing secrets, and
* - managing permissions
*/
export class NillionClient {
  free(): void;
/**
* Creates an instance of Nillion Client
*
* @param {UserKey} user_key - The user private key
* @param {NodeKey} node_key - The node private key
* @param {Array<string>} bootnodes - The Nillion cluster bootnode websocket multiaddresses. A websocket multiaddress has `/ws` or `/wss` (secure sockets) in the address. Example: "/ip4/127.0.0.1/tcp/14211/wss/p2p/12D3KooWCAGu6gqDrkDWWcFnjsT9Y8rUzUH8buWjdFcU3TfWRmuN"
* @param {any} payments_config - The payments configuration
*
* @example
* const user_key = UserKey.generate();
* const node_key = NodeKey.from_seed('your-seed-here');
* const client = new NillionClient(
*     user_key,
*     node_key,
*     bootnodes,
*     payments_config
*   );
*/
  constructor(user_key: UserKey, node_key: NodeKey, bootnodes: (string)[], payments_config: any);
/**
* Enable remote logging
*
* Writes client logs to a websocket that can be accessed in URL: ws://127.0.0.1:11100/logs.
* You can use tools like [websocat](https://github.com/vi/websocat) to access and read these logs.
*
* @example
* nillionClient.enable_remote_logging();
*/
  static enable_remote_logging(): void;
/**
* Store a secret on Nillion
*
* @param {string} cluster_id - The targeted cluster identifier
* @param {Secrets} secrets - The collection of secrets to store
* @param {ProgramBindings | undefined} bindings - Optional bindings between network parties and the parties are defined by the program
* @param {Permissions | undefined} permissions - Optional permissions to be associated with the secrets. By default the user has full access to the secret.
* @returns {Promise<string>} A store ID that can be used to retrieve the secret.
*
* @example
* const secrets = new Secrets();
* secrets.insert('secret1', Secret.new_integer('1'));
* const store_id = await nillionClient.store_secrets(cluster_id, secrets);
*/
  store_secrets(cluster_id: string, secrets: Secrets, bindings?: ProgramBindings, permissions?: Permissions): Promise<string>;
/**
* Retrieve a secret already stored in Nillion
*
* @param {string} cluster_id - UUID of the targeted preprocessing cluster
* @param {string} store_id - The store secret operation identifier for the secret collection that will be retrieved.
* @param {string} secret_id - The secret identifier inside the secrets collection
* @return {Promise<Secret>} - The secret identified by `secret_id`
*
* @example
* const secret = await nillionClient.retrieve_secret(cluster_id, store_id, secret_id);
*/
  retrieve_secret(cluster_id: string, store_id: string, secret_id: string): Promise<Secret>;
/**
* Update a secret stored in Nillion
*
* @param {string} cluster_id - UUID of the targeted preprocessing cluster
* @param {string} store_id - The store secret operation identifier for the secret collection that will be updated.
* @param {Secrets} secrets - The new secret collection that will replace the existing one
* @return {Promise<string>} The unique identifier of the update operation
*
* @example
* const secrets = new Secrets();
* secrets.insert('secret1', Secret.new_integer('2'));
* const action_id = await nillionClient.update_secrets(cluster_id, store_id, secrets);
*/
  update_secrets(cluster_id: string, store_id: string, secrets: Secrets, bindings?: ProgramBindings): Promise<string>;
/**
* Delete secrets collection from the network.
*
* @param {string} cluster_id - UUID of the targeted preprocessing cluster
* @param {string} store_id - The store secret operation identifier for the secret collection that will be deleted.
* @return {Promise}
*
* @example
* await nillionClient.delete_secrets(cluster_id, store_id);
*/
  delete_secrets(cluster_id: string, store_id: string): Promise<void>;
/**
* Compute in the Nillion Network. This method invokes the compute operation in Nillion.
* It returns a compute ID that can be used by `compute_result` to fetch
* the results of this computation.
*
* @param {string} cluster_id - Identifier of the targeted cluster
* @param {ProgramBindings} bindings - The program bindings for the computation
* @param {Array.<string>} store_ids - The store IDs of the secrets to use for the computation
* @param {Secrets} secrets - Additional secrets to use for the computation
* @param {PublicVariables} public_variables - Public variables that are used in the computation.
* @return {Promise<Object>} A computation UUID.
*
* @example
* const bindings = new ProgramBindings();
* bindings.add_input_party('Party1', '12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH');
* const secrets = new Secrets();
* secrets.insert('secret1', Secret.new_integer('1'));
* const public_variables = new PublicVariables();
* const result_id = await nillionClient.compute(cluster_id, bindings, ['store1'], secrets, public_variables);
*/
  compute(cluster_id: string, bindings: ProgramBindings, store_ids: (string)[], secrets: Secrets, public_variables: PublicVariables): Promise<string>;
/**
* Fetch the result of the compute in the Nillion Network
*
* @param {string} result_id - The computation UUID returned after calling `compute`
* @return {Promise<Object>} - The result of the computation
*
* @example
* const result = await nillionClient.compute_result(result_id);
*/
  compute_result(result_id: string): Promise<any>;
/**
* Retrieve permissions for a group of secrets stored in Nillion.
*
* @param {string} cluster_id - The identifier of the target cluster
* @param {string} store_id - The store secret identifier for the secret collection where the secrets are
* @return {Promise<Permissions>} The permissions associated to the secrets
*
* @example
* const permissions = await nillionClient.retrieve_permissions(cluster_id, store_id);
*/
  retrieve_permissions(cluster_id: string, store_id: string): Promise<Permissions>;
/**
* Update permissions for a group of secrets stored in Nillion.
*
* @param {string} cluster_id - The identifier of the target cluster
* @param {string} store_id - The store secret identifier for the secret collection where the secrets are
* @param {Permissions} permissions - The permissions that will replace the existing permissions for the secrets
* @return {Promise<String>} The action ID corresponding to the update operation
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* permissions.add_update_permissions(["user_id"]);
* const action_id = await nillionClient.update_permissions(cluster_id, store_id, permissions);
*/
  update_permissions(cluster_id: string, store_id: string, permissions: Permissions): Promise<string>;
/**
* Store a program in the Nillion Network
*
* @param {string} cluster_id - UUID of the targeted preprocessing cluster
* @param {string} program_name - The name of the program
* @param {UInt8Array} program - The compiled nada program in binary format
* @return The action ID associated with the action of storing a program
*
* @example
* const action_id = await nillionClient.store_program(cluster_id, 'program_name', program);
*/
  store_program(cluster_id: string, program_name: string, program: Uint8Array): Promise<string>;
/**
* Returns information about a Nillion cluster
*
* @param {string} cluster_id - Identifier of the target cluster
* @return {Promise<ClusterDescriptor>} The cluster descriptor for the given cluster
*
* @example
* const cluster_descriptor = await nillionClient.cluster_information(cluster_id);
*/
  cluster_information(cluster_id: string): Promise<ClusterDescriptor>;
/**
* Enables tracking for the user.
*
* Enables tracking of client actions (store, retrieve, compute ...)
* @return {Promise}
*
* @example
* await nillionClient.enable_tracking();
*/
  static enable_tracking(wallet_addr?: string): void;
/**
* Get the build version of the Nillion client.
*
* @return {string} A string representation of the build version
*
* @example
* const version = nillionClient.build_version;
*/
  static readonly build_version: string;
/**
* Get the party identifier for the current client.
* @return {string} The party identifier for the current client
*
* @example
* const partyId = nillionClient.party_id;
*/
  readonly party_id: string;
/**
* Get the user identifier for the current user.
*
* @return {string} - The Nillion user identifier for the current user
*
* @example
* const userId = nillionClient.user_id;
*/
  readonly user_id: string;
}
/**
* Node key
*
* The node key is used to authenticate the node in the Nillion network.
* The key can be generated from a seed or from a base58 string.
*
* @hideconstructor
* @example
*
* const key = new NodeKey.from_seed("my_seed");
*/
export class NodeKey {
  free(): void;
/**
* Generates a private key using a seed.
*
* @param {string} seed - The seed that will be used to generate the NodeKey
* @return {NodeKey} A NodeKey
*
* @example
*
* const key = new NodeKey.from_seed("my_seed");
*/
  static from_seed(seed: string): NodeKey;
/**
* Decodes a private key from a string encoded in Base58.
*
* @param {string} contents - A base58 string
* @return {NodeKey} An instance of NodeKey matching the string provided
*
* @example
*
* const key = new NodeKey.from_base58(<base 58 encoded data>);
*/
  static from_base58(contents: string): NodeKey;
}
/**
* The permissions data structure.
*
* In Nillion, every stored secret has associated a set of permissions upon creation.
* If no permissions are provided, the network will grant ownership as well as update, delete and retrieve permissions
* to the user storing the secret.
*
* For each compute operation, the secrets need to have granted compute permissions for the program and the user
* accessing the secret for the purpose of a computation.
*
* Permissions for any store secret can be updated and retrieved by the owner using `update_permissions` and `retrieve_permissions` operations
* respectively.
*/
export class Permissions {
  free(): void;
/**
* Build a new empty instance of Permissions
*
* @example
* const permissions = new Permissions();
*/
  constructor();
/**
* Builds a new instance of Permissions with the default set for the user identifier.
*
* By default, the user identifier will be granted ownership of the secret as well as full access to the secret.
* No compute permissions are granted by default unless a program is specified. They need to be assigned separately.
*
* @param {string} user_id - The Nillion user identifier
* @param {string | undefined } program - Optionally specify a Program ID to apply compute permissions
* @returns {Permissions} An instance of Permissions with the default configuration for the user
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
*/
  static default_for_user(user_id: string, program?: string): Permissions;
/**
* Add retrieve permissions to the Permissions instance for the
* given list of user IDs
*
* @param {Array<string>} user_ids - The list of user identifiers that will be granted retrieve permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* permissions.add_retrieve_permissions(["user_id"]);
*/
  add_retrieve_permissions(user_ids: (string)[]): void;
/**
* Add update permissions to the Permissions instance for the
* given list of user IDs
*
* @param {Array<string>} user_ids - The list of user identifiers that will be granted update permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* permissions.add_update_permissions(["user_id"]);
*/
  add_update_permissions(user_ids: (string)[]): void;
/**
* Add delete permissions to the Permissions instance for the
* given list of user IDs
*
* @param {Array<string>} user_ids - The list of user identifiers that will be granted delete permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* permissions.add_delete_permissions(["user_id"]);
*/
  add_delete_permissions(user_ids: (string)[]): void;
/**
* Add compute permissions to the Permissions instance for the
* given list of user IDs
*
* @param {any} permissions - object where the keys are the user identities and for each key the values are a list of program identifiers that
*     user will be granted compute permission for.
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* permissions.add_compute_permissions({
*     "user_id": ["program_id"]
* });
*/
  add_compute_permissions(permissions: any): void;
/**
* Returns true if user has retrieve permissions
*
* @param {string} user_id - the user identifier
* @return {boolean} true if the user has retrieve permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* const retrieve_allowed = permissions.is_retrieve_allowed("user_id");
*/
  is_retrieve_allowed(user_id: string): boolean;
/**
* Returns true if user has update permissions
*
* @param {string} user_id - the user identifier
* @return {boolean} true if the user has update permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* const update_allowed = permissions.is_update_allowed("user_id");
*/
  is_update_allowed(user_id: string): boolean;
/**
* Returns true if user has delete permissions
*
* @param {string} user_id - the user identifier
* @return {boolean} true if the user has delete permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* const delete_allowed = permissions.is_delete_allowed("user_id");
*/
  is_delete_allowed(user_id: string): boolean;
/**
* Returns true if user has compute permissions for every single program
*
* @param {string} user_id - the user identifier
* @param {string} program - the program identifier
* @return {boolean} true if the user has compute permissions
*
* @example
* const permissions = Permissions.default_for_user(nillionClient.user_id);
* const compute_allowed = permissions.is_compute_allowed("user_id", "program_id");
*/
  is_compute_allowed(user_id: string, program: string): boolean;
}
/**
* The pre-processing configuration
* @hideconstructor
*/
export class PreprocessingConfig {
  free(): void;
/**
* The ALPHA generation protocol configuration.
* @return {PreprocessingProtocolConfig} The ALPHA generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const alpha = preprocessing.alpha;
*/
  readonly alpha: PreprocessingProtocolConfig;
/**
* The PREP-COMPARE generation protocol configuration.
* @return {PreprocessingProtocolConfig} The PREP-COMPARE generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const compare = preprocessing.compare;
*/
  readonly compare: PreprocessingProtocolConfig;
/**
* The PREP-DIV-INT-SECRET generation protocol configuration.
* @return {PreprocessingProtocolConfig} The PREP-DIV-INT-SECRET generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const division_integer_secret = preprocessing.division_integer_secret;
*/
  readonly division_integer_secret: PreprocessingProtocolConfig;
/**
* The LAMBDA generation protocol configuration.
* @return {PreprocessingProtocolConfig} The LAMBDA generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const lambda = preprocessing.lambda;
*/
  readonly lambda: PreprocessingProtocolConfig;
/**
* The PREP-MODULO generation protocol configuration.
* @return {PreprocessingProtocolConfig} The PREP-MODULO generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const modulo = preprocessing.modulo;
*/
  readonly modulo: PreprocessingProtocolConfig;
/**
* The PREP-PUBLIC-OUTPUT-EQUALITY generation protocol configuration.
* @return {PreprocessingProtocolConfig} The PREP-PUBLIC-OUTPUT-EQUALITY generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const public_output_equality = preprocessing.public_output_equality;
*/
  readonly public_output_equality: PreprocessingProtocolConfig;
/**
* The PREP-SHARE-TO-PARTICLE generation protocol configuration.
* @return {PreprocessingProtocolConfig} The PREP-SHARE-TO-PARTICLE generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const share_to_particle = preprocessing.share_to_particle;
*/
  readonly share_to_particle: PreprocessingProtocolConfig;
/**
* The PREP-TRUNCPR generation protocol configuration
* @return {PreprocessingProtocolConfig} The PREP-TRUNCPR generation protocol configuration
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const truncpr = preprocessing.truncpr;
*/
  readonly truncpr: PreprocessingProtocolConfig;
}
/**
* The pre-processing protocol configuration
* @hideconstructor
*/
export class PreprocessingProtocolConfig {
  free(): void;
/**
* The number of elements to be generated on every run.
*
* @example
* const descriptor = await nillionClient.cluster_information();
* const preprocessing = descriptor.preprocessing;
* const lambda = preprocessing.lambda;
* const batch_size = lambda.batch_size;
*/
  readonly batch_size: number;
}
/**
* Program Bindings
*/
export class ProgramBindings {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* Creates a new ProgramBindings
*
* @param {string} program_id - A program identifier, this is usually the given name of the program
* @return {ProgramBindings} A new instance of ProgramBindings
*
* @example
* const bindings = new ProgramBindings("simple_program");
*/
  constructor(program_id: string);
/**
* Bind an input party with a name
*
* @param {string} name - Name of the input party
* @param {string} id - Identifier of the party
*
* @example
* bindings.add_input_party("Party1", "12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH");
*/
  add_input_party(name: string, id: string): void;
/**
* Bind an output party with a name
*
* @param {string} name - Name of the input party
* @param {string} id - Identifier of the party
*
* @example
* bindings.add_output_party("Party2", "12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH");
*/
  add_output_party(name: string, id: string): void;
}
/**
* Public Variable.
*
* This type represents a public variable in the Nillion network.
* Public variables can be provided as part of program inputs, as well as secrets.
*
* @hideconstructor
*/
export class PublicVariable {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* Create a new public integer with the provided value.
*
* @param {string} value - The value must be a valid string representation of an integer.
* @return {PublicVariable} The encoded public variable corresponding to the value provided
*
* @example
* const public_variable = PublicVariable.new_integer("-23");
*/
  static new_integer(value: string): PublicVariable;
/**
* Create a new public unsigned integer with the provided value.
*
* @param {string} value - The value must be a valid string representation of an unsigned integer.
* @return {PublicVariable} The encoded public variable corresponding to the value provided
*
* @example
* const public_variable = PublicVariable.new_unsigned_integer("23");
*/
  static new_unsigned_integer(value: string): PublicVariable;
/**
* Convert this public variable into a string representation of the underlying numeric value.
*
* This only works for numeric public variables, such as integers and unsigned integers.
* @return {string} The string representation of the numeric value contained in the public variable.
*
* @example
* const public_variable = PublicVariable.new_integer("-23");
* const value = public_variable.to_integer();
*/
  to_integer(): string;
}
/**
* Public variables
*
* A collection of named public variables
*/
export class PublicVariables {
  free(): void;
/**
* Creates a new instance of PublicVariables without values.
* @return {PublicVariables} The new instance of PublicVariables
*
* @example
* const publicVariables = new PublicVariables();
*/
  constructor();
/**
* Add encoded public variable to the PublicVariables collection.
* @param {string} name - The name of the public variable
* @param {PublicVariable} input - The public variable to add
*
* @example
* publicVariables.insert("my_integers", PublicVariable.new_integer("23"));
*/
  insert(name: string, input: PublicVariable): void;
/**
* Get the number of public variables.
* @return {number} The number of public variables in the collection
*
* @example
* const length = publicVariables.length;
*/
  readonly length: number;
}
/**
* Secret
*
* This type represents a secret in the Nillion network. This class provides utilities
* to encode numerical and binary values into secrets. It also provides methods to decode
* the secret into a numerical value.
*
* @hideconstructor
*/
export class Secret {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* Create a new secret integer with the provided value.
*
* @param {string} value - The value must be a valid string representation of an integer.
* @return {Secret} The encoded secret corresponding to the value provided
*
* @example
* const secret = Secret.new_integer("-23");
*/
  static new_integer(value: string): Secret;
/**
* Create a new secret unsigned integer with the provided value.
*
* @param {string} value - The value must be a valid string representation of an unsigned integer.
* @return {Secret} The encoded secret corresponding to the value provided
*
* @example
* const secret = Secret.new_integer("23");
*/
  static new_unsigned_integer(value: string): Secret;
/**
* Create a new secret blob with the provided value.
*
* @param {Uint8Array} value - The blob in binary (byte array) encoded format
* @return {Secret} The encoded secret corresponding to the value provided
*
* @example
* const secret = Secret.new_blob([1,0,1,222,21]);
*/
  static new_blob(value: Uint8Array): Secret;
/**
* Convert this secret into a byte array.
*
* This is only valid for blob secrets.
* @return {Uint8Array} the byte array contained in this secret.
* @throws {Error} if the secret is not a blob.
*
* @example
* const secret = Secret.new_blob([1,0,1,222,21]);
* const byteArray = secret.to_byte_array();
*/
  to_byte_array(): Uint8Array;
/**
* Convert this secret into a string representation of the underlying numeric value.
*
* This only works for numeric secrets, such as integers and unsigned integers.
* @return {string} a string representation of the underlying numeric value of this secret
*
* @example
* const secret = Secret.new_integer("23");
* const value = secret.to_integer();
*/
  to_integer(): string;
}
/**
* A collection of named secrets.
*/
export class Secrets {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
/**
* Creates a new instance of Secrets without values.
*
* @example
* const secrets = new Secrets();
*/
  constructor();
/**
* Add encoded secret to Secrets collection.
*
* @param {string} name - The name of the secret
* @param {Secret} input - The secret to be added
*
* @example
* secrets.insert("my_secret", Secret.new_integer("23"));
*/
  insert(name: string, input: Secret): void;
/**
* Get the number of secrets.
*
* @example
* const length = secrets.length;
*/
  readonly length: number;
}
/**
* User key
*
* The user key is used as the user identity in the Nillion network.
* The key can be generated from a seed or from a base58 string.
*
* @hideconstructor
* @example
*
* const key = new UserKey.from_seed("my_seed");
*/
export class UserKey {
  free(): void;
/**
* Generate a new random public/private key.
* Uses a cryptographically secure pseudo-random number generator.
*
* @return {UserKey} a new instance of UserKey
*
* @example
*
* const key = new UserKey.generate();
*/
  static generate(): UserKey;
/**
* Generate a new public/private key.
* Uses a seed to generate the keys via a cryptographically secure pseudo-random number generator.
*
* @param {string} seed - The seed that will be used to generate the key
*
* @return {UserKey} The user key generated using the seed provided
*
* @example
*
* const key = new UserKey.from_seed("my_seed");
*/
  static from_seed(seed: string): UserKey;
/**
* Returns the public key corresponding to this key.
*
* @return {string} The public key as an UTF-8 encoded string.
*
* @example
*
* const key = new UserKey.from_seed("my_seed");
* const public_key = key.public_key();
*/
  public_key(): string;
/**
* Decodes a UserKey from a Base58-encoded String
*
* @param {string} contents - The private key encoded in Base58 format
* @return {UserKey} The decoded instance of UserKey
*
* @example
*
* const key = new UserKey.from_base58(<base 58 encoded data>);
*/
  static from_base58(contents: string): UserKey;
/**
* Returns the key in Base58 encoded form.
*
* @return {string} the key encoded as a Base58 string
* @example
*
* const key = new UserKey.from_seed("my_seed");
* const base58_key = key.to_base58();
*/
  to_base58(): string;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly __wbg_loaderhelper_free: (a: number) => void;
  readonly loaderhelper_mainJS: (a: number) => number;
  readonly worker_entry_point: (a: number) => void;
  readonly __wbg_publicvariable_free: (a: number) => void;
  readonly publicvariable_new_integer: (a: number, b: number, c: number) => void;
  readonly publicvariable_new_unsigned_integer: (a: number, b: number, c: number) => void;
  readonly publicvariable_to_integer: (a: number, b: number) => void;
  readonly __wbg_publicvariables_free: (a: number) => void;
  readonly publicvariables_new: (a: number) => void;
  readonly publicvariables_insert: (a: number, b: number, c: number, d: number) => void;
  readonly publicvariables_length: (a: number) => number;
  readonly __wbg_programbindings_free: (a: number) => void;
  readonly programbindings_new: (a: number, b: number, c: number) => void;
  readonly programbindings_add_input_party: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly programbindings_add_output_party: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly __wbg_clusterdescriptor_free: (a: number) => void;
  readonly clusterdescriptor_id: (a: number, b: number) => void;
  readonly clusterdescriptor_parties: (a: number, b: number) => void;
  readonly clusterdescriptor_prime: (a: number, b: number) => void;
  readonly clusterdescriptor_kappa: (a: number) => number;
  readonly clusterdescriptor_preprocessing: (a: number) => number;
  readonly __wbg_preprocessingconfig_free: (a: number) => void;
  readonly preprocessingconfig_lambda: (a: number) => number;
  readonly preprocessingconfig_alpha: (a: number) => number;
  readonly preprocessingconfig_compare: (a: number) => number;
  readonly preprocessingconfig_division_integer_secret: (a: number) => number;
  readonly preprocessingconfig_modulo: (a: number) => number;
  readonly preprocessingconfig_share_to_particle: (a: number) => number;
  readonly preprocessingconfig_public_output_equality: (a: number) => number;
  readonly preprocessingconfig_truncpr: (a: number) => number;
  readonly __wbg_preprocessingprotocolconfig_free: (a: number) => void;
  readonly preprocessingprotocolconfig_batch_size: (a: number) => number;
  readonly __wbg_secret_free: (a: number) => void;
  readonly secret_new_integer: (a: number, b: number, c: number) => void;
  readonly secret_new_unsigned_integer: (a: number, b: number, c: number) => void;
  readonly secret_new_blob: (a: number, b: number) => number;
  readonly secret_to_byte_array: (a: number, b: number) => void;
  readonly secret_to_integer: (a: number, b: number) => void;
  readonly __wbg_secrets_free: (a: number) => void;
  readonly secrets_insert: (a: number, b: number, c: number, d: number) => void;
  readonly __wbg_nodekey_free: (a: number) => void;
  readonly nodekey_from_seed: (a: number, b: number) => number;
  readonly nodekey_from_base58: (a: number, b: number) => number;
  readonly __wbg_userkey_free: (a: number) => void;
  readonly userkey_generate: () => number;
  readonly userkey_from_seed: (a: number, b: number, c: number) => void;
  readonly userkey_public_key: (a: number, b: number) => void;
  readonly userkey_from_base58: (a: number, b: number, c: number) => void;
  readonly userkey_to_base58: (a: number, b: number) => void;
  readonly __wbg_nillionclient_free: (a: number) => void;
  readonly nillionclient_new: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly nillionclient_enable_remote_logging: () => void;
  readonly nillionclient_party_id: (a: number, b: number) => void;
  readonly nillionclient_user_id: (a: number, b: number) => void;
  readonly nillionclient_store_secrets: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly nillionclient_retrieve_secret: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => number;
  readonly nillionclient_update_secrets: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => number;
  readonly nillionclient_delete_secrets: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly nillionclient_compute: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => number;
  readonly nillionclient_compute_result: (a: number, b: number, c: number) => number;
  readonly nillionclient_retrieve_permissions: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly nillionclient_update_permissions: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly nillionclient_store_program: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => number;
  readonly nillionclient_cluster_information: (a: number, b: number, c: number) => number;
  readonly nillionclient_enable_tracking: (a: number, b: number, c: number) => void;
  readonly nillionclient_build_version: (a: number) => void;
  readonly __wbg_permissions_free: (a: number) => void;
  readonly permissions_new: () => number;
  readonly permissions_default_for_user: (a: number, b: number, c: number, d: number) => number;
  readonly permissions_add_retrieve_permissions: (a: number, b: number, c: number, d: number) => void;
  readonly permissions_add_update_permissions: (a: number, b: number, c: number, d: number) => void;
  readonly permissions_add_delete_permissions: (a: number, b: number, c: number, d: number) => void;
  readonly permissions_add_compute_permissions: (a: number, b: number, c: number) => void;
  readonly permissions_is_retrieve_allowed: (a: number, b: number, c: number) => number;
  readonly permissions_is_update_allowed: (a: number, b: number, c: number) => number;
  readonly permissions_is_delete_allowed: (a: number, b: number, c: number) => number;
  readonly permissions_is_compute_allowed: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly secrets_length: (a: number) => number;
  readonly secrets_new: (a: number) => void;
  readonly memory: WebAssembly.Memory;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_export_3: WebAssembly.Table;
  readonly wasm_bindgen__convert__closures__invoke1_mut__h2fed68bc4612ded8: (a: number, b: number, c: number) => void;
  readonly wasm_bindgen__convert__closures__invoke0_mut__hba14ce934dce0051: (a: number, b: number) => void;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly wasm_bindgen__convert__closures__invoke2_mut__h34802d39eb00c353: (a: number, b: number, c: number, d: number) => void;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_thread_destroy: (a?: number, b?: number) => void;
  readonly __wbindgen_start: () => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
* @param {WebAssembly.Memory} maybe_memory
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput, maybe_memory?: WebAssembly.Memory): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
* @param {WebAssembly.Memory} maybe_memory
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: InitInput | Promise<InitInput>, maybe_memory?: WebAssembly.Memory): Promise<InitOutput>;
